<!DOCTYPE html>
<html>
<head>
<title>Bai4-Stack_Queue_Graph-BFS-DFS.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="stack-queue--%C4%91%E1%BB%93-th%E1%BB%8B-bfs-dfs">Stack, Queue &amp; Đồ thị (BFS, DFS)</h1>
<h1 id="m%E1%BB%A5c-l%E1%BB%A5c">Mục lục</h1>
<ul>
<li><a href="#1-stack--queue">1. Stack &amp; Queue</a>
<ul>
<li><a href="#11-stack-ng%C4%83n-x%E1%BA%BFp">1.1. Stack (Ngăn xếp)</a></li>
<li><a href="#12-queue-h%C3%A0ng-%C4%91%E1%BB%A3i">1.2. Queue (Hàng đợi)</a></li>
</ul>
</li>
<li><a href="#2-t%E1%BB%95ng-quan-l%C3%AD-thuy%E1%BA%BFt-%C4%91%E1%BB%93-th%E1%BB%8B">2. Tổng quan lí thuyết đồ thị</a>
<ul>
<li><a href="#21-%C4%91%E1%BB%93-th%E1%BB%8B-l%C3%A0-g%C3%AC">2.1. Đồ thị là gì?</a></li>
<li><a href="#22-c%C3%A1c-d%E1%BA%A1ng-%C4%91%E1%BB%93-th%E1%BB%8B">2.2. Các dạng đồ thị</a>
<ul>
<li><a href="#221-%C4%91%C6%A1n-%C4%91%E1%BB%93-th%E1%BB%8B">2.2.1. Đơn đồ thị</a></li>
<li><a href="#222-%C4%91a-%C4%91%E1%BB%93-th%E1%BB%8B">2.2.2. Đa đồ thị</a></li>
<li><a href="#223-%C4%91%E1%BB%93-th%E1%BB%8B-v%C3%B4-h%C6%B0%E1%BB%9Bng">2.2.3. Đồ thị vô hướng</a></li>
<li><a href="#224-%C4%91%E1%BB%93-th%E1%BB%8B-c%C3%B3-h%C6%B0%E1%BB%9Bng">2.2.4. Đồ thị có hướng</a></li>
</ul>
</li>
<li><a href="#23-c%C3%A1c-c%C3%A1ch-bi%E1%BB%83u-di%E1%BB%85n-%C4%91%E1%BB%93-th%E1%BB%8B">2.3. Các cách biểu diễn đồ thị</a>
<ul>
<li><a href="#231-ma-tr%E1%BA%ADn-k%E1%BB%81-adjacency-matrix">2.3.1. Ma trận kề (Adjacency matrix)</a></li>
<li><a href="#232-danh-s%C3%A1ch-k%E1%BB%81-adjacency-list-hay-d%C3%B9ng-nh%E1%BA%A5t">2.3.2. Danh sách kề (Adjacency list)</a></li>
<li><a href="#233-danh-s%C3%A1ch-c%E1%BA%A1nh-edge-list">2.3.3. Danh sách cạnh (Edge list)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-bfs-breadth-first-search---t%C3%ACm-ki%E1%BA%BFm-theo-chi%E1%BB%81u-r%E1%BB%99ng">3. BFS (Breadth-First Search - Tìm kiếm theo chiều rộng)</a></li>
<li><a href="#4-dfs-depth-first-search---t%C3%ACm-ki%E1%BA%BFm-theo-chi%E1%BB%81u-s%C3%A2u">4. DFS (Depth-First Search - Tìm kiếm theo chiều sâu)</a></li>
<li><a href="#5-x%C3%A1c-%C4%91%E1%BB%8Bnh-th%C3%A0nh-ph%E1%BA%A7n-li%C3%AAn-th%C3%B4ng-connected-components">5. Xác định thành phần liên thông (Connected Components)</a></li>
</ul>
<hr>
<h2 id="1-stack--queue">1. Stack &amp; Queue</h2>
<h3 id="11-stack-ng%C4%83n-x%E1%BA%BFp">1.1. Stack (Ngăn xếp)</h3>
<ul>
<li><strong>Lý thuyết:</strong> Hoạt động theo nguyên tắc <strong>LIFO (Last-In, First-Out)</strong></li>
<li><strong>Các thao tác chính (Độ phức tạp thời gian O(1) cho mỗi thao tác):</strong>
<ul>
<li><code>push(val)</code>: Thêm phần tử vào đỉnh stack.</li>
<li><code>pop()</code>: Xóa phần tử ở đỉnh stack.</li>
<li><code>top()</code>: Trả về phần tử ở đỉnh stack (không xóa).</li>
<li><code>empty()</code>: Kiểm tra stack có rỗng không.</li>
<li><code>size()</code>: Trả về số lượng phần tử.</li>
</ul>
</li>
<li><strong>Độ phức tạp không gian:</strong> O(N) với N là số phần tử trong stack.</li>
</ul>
<h3 id="12-queue-h%C3%A0ng-%C4%91%E1%BB%A3i">1.2. Queue (Hàng đợi)</h3>
<ul>
<li><strong>Lý thuyết:</strong> Hoạt động theo nguyên tắc <strong>FIFO (First-In, First-Out)</strong></li>
<li><strong>Các thao tác chính (Độ phức tạp thời gian O(1) cho mỗi thao tác):</strong>
<ul>
<li><code>push(val)</code>: Thêm phần tử vào cuối queue.</li>
<li><code>pop()</code>: Xóa phần tử ở đầu queue.</li>
<li><code>front()</code>: Trả về phần tử ở đầu queue (không xóa).</li>
<li><code>back()</code>: Trả về phần tử ở cuối queue (không xóa).</li>
<li><code>empty()</code>: Kiểm tra queue có rỗng không.</li>
<li><code>size()</code>: Trả về số lượng phần tử.</li>
</ul>
</li>
<li><strong>Độ phức tạp không gian:</strong> O(N) với N là số phần tử trong queue.</li>
</ul>
<h2 id="2-t%E1%BB%95ng-quan-l%C3%AD-thuy%E1%BA%BFt-%C4%91%E1%BB%93-th%E1%BB%8B">2. Tổng quan lí thuyết đồ thị</h2>
<h3 id="21-%C4%91%E1%BB%93-th%E1%BB%8B-l%C3%A0-g%C3%AC">2.1. Đồ thị là gì?</h3>
<p><strong>Web hay để học đồ thị - biểu diễn đồ thị:</strong> <a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></p>
<img src="https://i.imgur.com/ZikFiky.png" alt="Graph Sample" width="800" height="400"/>
<p><em>Đây là một đồ thị vô hướng, Đồ thị có 6 đỉnh được đánh số từ 0 đến 5.</em></p>
<p>Một đồ thị gồm: các <strong>đỉnh (Vertices)</strong> hoặc được gọi là <strong>nút (nodes)</strong>, và những đường thẳng/cong nối các đỉnh - gọi là các <strong>cạnh (edges)</strong>.</p>
<ul>
<li>Kí hiệu: <strong>G = (V, E)</strong> với V là tập đỉnh (Vertices), E là tập cạnh (Edges).</li>
</ul>
<h3 id="22-c%C3%A1c-d%E1%BA%A1ng-%C4%91%E1%BB%93-th%E1%BB%8B">2.2. Các dạng đồ thị</h3>
<h4 id="221-%C4%91%C6%A1n-%C4%91%E1%BB%93-th%E1%BB%8B">2.2.1. Đơn đồ thị</h4>
<img src="https://i.imgur.com/njd1AQ8.png" alt="Đơn đồ thị" width="300" height="300"/>
<p><em>Đơn đồ thị: Không có cạnh song song (nhiều hơn 1 cạnh nối cùng 1 cặp đỉnh) và không có khuyên (cạnh nối 1 đỉnh với chính nó).</em></p>
<h4 id="222-%C4%91a-%C4%91%E1%BB%93-th%E1%BB%8B">2.2.2. Đa đồ thị</h4>
<p><img src="https://i.imgur.com/d4YC54E.png" alt="Đa đồ thị"></p>
<p><em>Đa đồ thị: Có thể có cạnh song song hoặc khuyên.</em></p>
<h4 id="223-%C4%91%E1%BB%93-th%E1%BB%8B-v%C3%B4-h%C6%B0%E1%BB%9Bng">2.2.3. Đồ thị vô hướng</h4>
<img src="https://i.imgur.com/QK6dHRt.png" alt="Đồ thị vô hướng" width="300" height="300"/>
<p><em>Các cạnh không có hướng (ví dụ: cạnh nối A và B là như nhau dù đi từ A-&gt;B hay B-&gt;A).</em></p>
<h4 id="224-%C4%91%E1%BB%93-th%E1%BB%8B-c%C3%B3-h%C6%B0%E1%BB%9Bng">2.2.4. Đồ thị có hướng</h4>
<img src="https://i.imgur.com/mN01UPA.png" alt="Đồ thị có hướng" width="300" height="300"/>
<p><em>Các cạnh có hướng xác định (ví dụ: cạnh đi từ A đến B khác với cạnh đi từ B đến A).</em></p>
<h3 id="23-c%C3%A1c-c%C3%A1ch-bi%E1%BB%83u-di%E1%BB%85n-%C4%91%E1%BB%93-th%E1%BB%8B">2.3. Các cách biểu diễn đồ thị</h3>
<p>Gọi |V| là số đỉnh và |E| là số cạnh của đồ thị.</p>
<h4 id="231-ma-tr%E1%BA%ADn-k%E1%BB%81-adjacency-matrix">2.3.1. Ma trận kề (Adjacency matrix)</h4>
<img src="https://i.imgur.com/qtmpEgd.png" alt="Ví dụ" width="400" height="300"/>
<p><strong>Ma trận kề của đồ thị:</strong></p>
<p>Để biểu diễn đồ thị <strong>G=(V, E)</strong> trong ma trận kề, ta xây dựng ma trận vuông <strong>A</strong> kích thước |V|x|V| với:</p>
<ul>
<li><strong>A[u][v] = 1</strong> nếu có cạnh nối đỉnh u và đỉnh v.</li>
<li><strong>A[u][v] = 0</strong> nếu không có cạnh nối trực tiếp giữa u và v.</li>
</ul>
<p>Dưới đây là ma trận kề của đồ thị ví dụ (vô hướng, không trọng số):</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:left"><strong>1</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left"><strong>2</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left"><strong>3</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p><strong>Lưu ý:</strong></p>
<ul>
<li>Nếu đồ thị <strong>có trọng số</strong>, thay <code>1</code> bằng trọng số cạnh w(u, v). Nếu không có cạnh, có thể dùng giá trị đặc biệt (ví dụ: vô cùng hoặc 0 tùy ngữ cảnh).</li>
<li>Nếu đồ thị <strong>vô hướng</strong>, ma trận kề là ma trận đối xứng (A[u][v] = A[v][u]).</li>
<li>Nếu đồ thị <strong>có hướng</strong>, A[u][v] = 1 chỉ biểu thị có cạnh từ u <em>đến</em> v.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1000</span>; <span class="hljs-comment">// Giới hạn số đỉnh tối đa</span>
<span class="hljs-keyword">int</span> adj[MAXN][MAXN];
<span class="hljs-keyword">int</span> n, m; <span class="hljs-comment">// n: số đỉnh, m: số cạnh</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;
    <span class="hljs-comment">// Khởi tạo ma trận kề với giá trị 0 (hoặc vô cùng nếu có trọng số âm)</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) {
            adj[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// Giả sử không có cạnh nối</span>
        }
    }

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i){
        <span class="hljs-keyword">int</span> u, v; <span class="hljs-comment">// Đọc cạnh nối giữa đỉnh u và v</span>
        <span class="hljs-comment">// Giả sử đỉnh được đánh số từ 0 đến n-1</span>
        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;
        <span class="hljs-comment">// int w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; // Nếu có trọng số</span>
        adj[u][v] = <span class="hljs-number">1</span>; <span class="hljs-comment">// Có cạnh từ u đến v</span>
        <span class="hljs-comment">// adj[u][v] = w; // Nếu có trọng số</span>
        adj[v][u] = <span class="hljs-number">1</span>; <span class="hljs-comment">// Nếu đồ thị vô hướng</span>
        <span class="hljs-comment">// adj[v][u] = w; // Nếu đồ thị vô hướng và có trọng số</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li><strong>Độ phức tạp không gian:</strong> O(|V|^2).</li>
<li><strong>Kiểm tra cạnh (u, v):</strong> O(1).</li>
<li><strong>Liệt kê các đỉnh kề của u:</strong> O(|V|).</li>
<li><strong>Phù hợp:</strong> Đồ thị dày đặc (số cạnh |E| xấp xỉ |V|^2).</li>
</ul>
<h4 id="232-danh-s%C3%A1ch-k%E1%BB%81-adjacency-list-hay-d%C3%B9ng-nh%E1%BA%A5t">2.3.2. Danh sách kề (Adjacency list) <strong><code>[Hay dùng nhất]</code></strong></h4>
<p>Lưu trữ một mảng gồm |V| danh sách. Mỗi danh sách <code>adj[u]</code> chứa các đỉnh kề với đỉnh <code>u</code>.</p>
<p><strong>Danh sách kề của đồ thị ví dụ:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Node</th>
<th style="text-align:left">Adj Nodes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">adj[0]</td>
<td style="text-align:left">{1}</td>
</tr>
<tr>
<td style="text-align:left">adj[1]</td>
<td style="text-align:left">{0, 2, 3}</td>
</tr>
<tr>
<td style="text-align:left">adj[2]</td>
<td style="text-align:left">{1, 3}</td>
</tr>
<tr>
<td style="text-align:left">adj[3]</td>
<td style="text-align:left">{1, 2}</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt; // Để dùng pair</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>; <span class="hljs-comment">// Giới hạn số đỉnh</span>
<span class="hljs-keyword">int</span> n, m;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; adj_no_weight[N];         <span class="hljs-comment">// Danh sách kề không trọng số</span>
<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; adj_weight[N]; <span class="hljs-comment">// Danh sách kề có trọng số {đỉnh kề, trọng số}</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;
    <span class="hljs-comment">// Ví dụ cho đồ thị không trọng số, vô hướng</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i){
        <span class="hljs-keyword">int</span> u, v; <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// Đỉnh từ 0 đến n-1</span>
        adj_no_weight[u].push_back(v);
        adj_no_weight[v].push_back(u); <span class="hljs-comment">// Bỏ dòng này nếu đồ thị có hướng</span>
    }

    <span class="hljs-comment">// Ví dụ cho đồ thị có trọng số, có hướng</span>
    <span class="hljs-comment">// for(int i = 0; i &lt; m; ++i){</span>
    <span class="hljs-comment">//     int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; // Cạnh từ u đến v, trọng số w</span>
    <span class="hljs-comment">//     adj_weight[u].push_back({v, w});</span>
    <span class="hljs-comment">//     // Nếu vô hướng thì thêm: adj_weight[v].push_back({u, w});</span>
    <span class="hljs-comment">// }</span>

    <span class="hljs-comment">// In danh sách kề của đỉnh 1 (ví dụ không trọng số)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cac dinh ke voi dinh 1: "</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> neighbor : adj_no_weight[<span class="hljs-number">1</span>]) {
        <span class="hljs-built_in">cout</span> &lt;&lt; neighbor &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li><strong>Độ phức tạp không gian:</strong> O(|V| + |E|).</li>
<li><strong>Kiểm tra cạnh (u, v):</strong> O(deg(u)), với deg(u) là bậc của đỉnh u (số cạnh nối với u).</li>
<li><strong>Liệt kê các đỉnh kề của u:</strong> O(deg(u)).</li>
<li><strong>Phù hợp:</strong> Đồ thị thưa (số cạnh |E| nhỏ hơn nhiều so với |V|^2), đây là trường hợp phổ biến.</li>
</ul>
<h4 id="233-danh-s%C3%A1ch-c%E1%BA%A1nh-edge-list">2.3.3. Danh sách cạnh (Edge list)</h4>
<p>Lưu trữ tất cả các cạnh của đồ thị trong một danh sách.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt; // Để sort</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> {</span>
    <span class="hljs-keyword">int</span> u, v, w; <span class="hljs-comment">// u: đỉnh bắt đầu, v: đỉnh kết thúc, w: trọng số</span>
    <span class="hljs-comment">// Constructor để dễ tạo Edge</span>
    Edge(<span class="hljs-keyword">int</span> start_node, <span class="hljs-keyword">int</span> end_node, <span class="hljs-keyword">int</span> weight) : u(start_node), v(end_node), w(weight) {}

    <span class="hljs-comment">// Nạp chồng toán tử so sánh để có thể sort theo trọng số (hữu ích cho một số thuật toán như Kruskal)</span>
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Edge &amp;other) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> w &lt; other.w;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n, m; <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// n: số đỉnh, m: số cạnh</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edges;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Nhap "</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">" canh (u v w):"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) {
        <span class="hljs-keyword">int</span> u, v, w; <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w; <span class="hljs-comment">// Đọc cạnh từ u đến v với trọng số w</span>
        edges.push_back(Edge(u, v, w));
        <span class="hljs-comment">// Nếu đồ thị vô hướng và cần biểu diễn 2 chiều, có thể thêm:</span>
        <span class="hljs-comment">// edges.push_back(Edge(v, u, w));</span>
    }

    <span class="hljs-comment">// Sắp xếp các cạnh theo trọng số tăng dần (ví dụ)</span>
    sort(edges.begin(), edges.end());

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Danh sach canh da sap xep:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) {
        <span class="hljs-built_in">cout</span> &lt;&lt; edge.u &lt;&lt; <span class="hljs-string">" -&gt; "</span> &lt;&lt; edge.v &lt;&lt; <span class="hljs-string">" (w="</span> &lt;&lt; edge.w &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li><strong>Độ phức tạp không gian:</strong> O(|E|).</li>
<li><strong>Kiểm tra cạnh (u, v):</strong> O(|E|) nếu chưa sắp xếp, hoặc O(log|E|) nếu đã sắp xếp và dùng tìm kiếm nhị phân (ít hiệu quả).</li>
<li><strong>Liệt kê các đỉnh kề của u:</strong> O(|E|).</li>
<li><strong>Phù hợp:</strong> Khi cần duyệt qua tất cả các cạnh một cách dễ dàng, ví dụ trong thuật toán Kruskal hoặc Bellman-Ford.</li>
</ul>
<h2 id="3-bfs-breadth-first-search---t%C3%ACm-ki%E1%BA%BFm-theo-chi%E1%BB%81u-r%E1%BB%99ng">3. BFS (Breadth-First Search - Tìm kiếm theo chiều rộng)</h2>
<ul>
<li><strong>Ý tưởng:</strong> Duyệt đồ thị theo từng lớp (level). Bắt đầu từ đỉnh nguồn <code>s</code>, thăm tất cả các đỉnh kề với <code>s</code> (lớp 1), sau đó thăm tất cả các đỉnh kề với các đỉnh ở lớp 1 (mà chưa được thăm - lớp 2), và cứ thế tiếp tục.</li>
<li><strong>Cấu trúc dữ liệu sử dụng:</strong> Hàng đợi (Queue) để lưu các đỉnh cần thăm theo thứ tự FIFO.</li>
<li><strong>Ứng dụng:</strong> Tìm đường đi ngắn nhất trên đồ thị không trọng số, kiểm tra tính liên thông, ...</li>
<li><strong>Độ phức tạp:</strong> O(|V| + |E|) khi dùng danh sách kề; O(|V|^2) khi dùng ma trận kề.</li>
</ul>
<p><strong>Các thành phần phụ trợ:</strong></p>
<ul>
<li><strong>Mảng</strong> <code>visited[]</code>: Đánh dấu các đỉnh đã thăm (boolean).</li>
<li><strong>Mảng</strong> <code>parent[]</code> (hoặc <code>par[]</code>): Lưu đỉnh cha của một đỉnh trong cây BFS, dùng để truy vết đường đi. <code>parent[s] = -1</code> (hoặc giá trị đặc biệt khác).</li>
<li><strong>Hàng đợi</strong> <code>q</code>: Lưu các đỉnh sẽ được thăm.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt; // Cho reverse</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>; <span class="hljs-comment">// Max số đỉnh</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; adj[N];     <span class="hljs-comment">// Danh sách kề (không trọng số)</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; visited;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;
<span class="hljs-keyword">int</span> n; <span class="hljs-comment">// Số đỉnh</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>{ <span class="hljs-comment">// s là đỉnh bắt đầu</span>
    <span class="hljs-comment">// Khởi tạo</span>
    visited.assign(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Giả sử đỉnh từ 1-&gt;n</span>
    parent.assign(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);

    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;

    q.push(s);
    visited[s] = <span class="hljs-literal">true</span>;
    parent[s] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Đỉnh nguồn không có cha</span>

    <span class="hljs-keyword">while</span> (!q.empty()) {
        <span class="hljs-keyword">int</span> u = q.front(); <span class="hljs-comment">// Lấy đỉnh đầu hàng đợi</span>
        q.pop();

        <span class="hljs-comment">// cout &lt;&lt; "Dang tham dinh: " &lt;&lt; u &lt;&lt; endl; // Debug</span>

        <span class="hljs-comment">// Duyệt các đỉnh kề v của u</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : adj[u]) {
            <span class="hljs-keyword">if</span> (!visited[v]) { <span class="hljs-comment">// Nếu đỉnh v chưa được thăm</span>
                visited[v] = <span class="hljs-literal">true</span>;
                parent[v] = u; <span class="hljs-comment">// Ghi nhận u là cha của v</span>
                q.push(v);     <span class="hljs-comment">// Thêm v vào hàng đợi để thăm sau</span>
                <span class="hljs-comment">// cout &lt;&lt; "  Phat hien dinh moi: " &lt;&lt; v &lt;&lt; ", cha la: " &lt;&lt; u &lt;&lt; endl; // Debug</span>
            }
        }
    }
}

<span class="hljs-comment">// Hàm truy vết và in đường đi từ s đến u</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> u)</span> </span>{
    <span class="hljs-keyword">if</span> (!visited[u]) { <span class="hljs-comment">// Kiểm tra xem có đến được u từ s không</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Khong co duong di tu "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">" den "</span> &lt;&lt; u &lt;&lt; <span class="hljs-string">"!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path;
        <span class="hljs-comment">// Lần ngược từ u về s thông qua mảng parent</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = u; v != <span class="hljs-number">-1</span>; v = parent[v]) {
            path.push_back(v);
        }
        <span class="hljs-comment">// Vì lần ngược nên cần đảo lại để có thứ tự từ s -&gt; u</span>
        reverse(path.begin(), path.end());

        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Duong di tu "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">" den "</span> &lt;&lt; u &lt;&lt; <span class="hljs-string">": "</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; path.size(); ++i) {
            <span class="hljs-built_in">cout</span> &lt;&lt; path[i] &lt;&lt; (i == path.size() - <span class="hljs-number">1</span> ? <span class="hljs-string">""</span> : <span class="hljs-string">" -&gt; "</span>);
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}

<span class="hljs-comment">// int main() {</span>
<span class="hljs-comment">//     // Giả sử đã nhập n, m và xây dựng adj[]</span>
<span class="hljs-comment">//     int start_node = 1; // Ví dụ bắt đầu từ đỉnh 1</span>
<span class="hljs-comment">//     int end_node = 5;   // Ví dụ muốn tìm đường đến đỉnh 5</span>
<span class="hljs-comment">//     bfs(start_node);</span>
<span class="hljs-comment">//     printPath(start_node, end_node);</span>
<span class="hljs-comment">//     return 0;</span>
<span class="hljs-comment">// }</span>
</div></code></pre>
<h2 id="4-dfs-depth-first-search---t%C3%ACm-ki%E1%BA%BFm-theo-chi%E1%BB%81u-s%C3%A2u">4. DFS (Depth-First Search - Tìm kiếm theo chiều sâu)</h2>
<ul>
<li><strong>Ý tưởng:</strong> Ưu tiên đi &quot;sâu&quot; nhất có thể theo một nhánh trước khi quay lại và thử nhánh khác. Bắt đầu từ đỉnh nguồn <code>s</code>, chọn một đỉnh kề <code>v</code> chưa thăm, đệ quy gọi DFS(v). Khi không còn đỉnh kề nào chưa thăm từ đỉnh hiện tại, quay lui (backtrack).</li>
<li><strong>Cấu trúc dữ liệu sử dụng:</strong> Ngăn xếp (Stack), có thể là stack hệ thống (thông qua đệ quy) hoặc stack tự tạo.</li>
<li><strong>Ứng dụng:</strong> Kiểm tra chu trình, tìm thành phần liên thông, tô màu đồ thị, sắp xếp topo (cho đồ thị có hướng, không chu trình), ...</li>
<li><strong>Độ phức tạp:</strong> O(|V| + |E|) khi dùng danh sách kề; O(|V|^2) khi dùng ma trận kề.</li>
</ul>
<p><strong>Các thành phần phụ trợ:</strong></p>
<ul>
<li><strong>Mảng</strong> <code>visited[]</code>: Đánh dấu các đỉnh đã thăm.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; adj[N];
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; visited;
<span class="hljs-keyword">int</span> n;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{
    visited[u] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : adj[u]) {
        <span class="hljs-keyword">if</span> (!visited[v]) {
            dfs(v);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Giả sử đã nhập n, m và xây dựng adj[]</span>
    visited.assign(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">int</span> start_node = <span class="hljs-number">1</span>;
    dfs(start_node);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="5-x%C3%A1c-%C4%91%E1%BB%8Bnh-th%C3%A0nh-ph%E1%BA%A7n-li%C3%AAn-th%C3%B4ng-connected-components">5. Xác định thành phần liên thông (Connected Components)</h2>
<ul>
<li><strong>Khái niệm:</strong> Một tập con các đỉnh của đồ thị vô hướng sao cho có đường đi giữa hai đỉnh bất kỳ trong tập con đó, và không có đường đi nào nối một đỉnh trong tập con với một đỉnh bên ngoài tập con.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {
    <span class="hljs-keyword">if</span> (!visit[i]) {
        cnt++;
        bfs(i); <span class="hljs-comment">//bfs(i)</span>
    }
}
<span class="hljs-built_in">cout</span> &lt;&lt; cnt; <span class="hljs-comment">//Số thành phần liên thông</span>
</div></code></pre>

</body>
</html>
